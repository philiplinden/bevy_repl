# Learning Clap
2025-08-04

**Derive pattern**: define structs with fields as input parameters and add attribues
to the struct to specify the clap attributes.

```rust
#[derive(Parser)]
struct Args {
    #[arg(short, long)]
    verbose: bool,
}
```

**Builder pattern**: build the clap command step by step as a method chain.

```rust
let mut cmd = Command::new("my_app");
cmd.version("1.0.0");
cmd.author("John Doe");
cmd.about("Does awesome things");
```

For this application, we should support the builder pattern first, and later try
to support the derive pattern. We should aspire to build the system in a way
that allows the user to use any feature flag to build custom commands, and then
use the minimal set of features to build the base-level REPL.

Remember that the `bevy_crossterm` TUI configures the UI and captures text
input, but `clap` is still responsible for parsing it. Confusingly, this means
that we output a `Command` struct and do _not_ implement the `Parser` trait.
`Parser` is used in the derive pattern, but we will be creating `Command`s and
directly calling `get_matches()` on them.

I'm not sure how "low-level" the custom commands should be. For now, I think we
will have the user supply `Command` objects to the REPL, and then during runtime
we will call `get_matches()` on the inputs with all of the `Command`s.
