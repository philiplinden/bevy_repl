# REPL Toggle and Raw Mode Behavior

This note explains why the toggle key wasn't recognized until pressing Enter and documents the design change to keep raw mode enabled across REPL toggles.

## Problem

- Crossterm emits immediate key events only when the terminal is in raw mode.
- Previously, when the REPL was disabled, we restored the terminal (exiting raw mode). In canonical mode, input is line-buffered, so the backtick (toggle) key was only delivered after Enter.
- This made it appear that the toggle only works after Enter, even when the REPL was enabled, because the raw-mode change was applied after input handling for that frame.

## Change

- Keep raw mode enabled across REPL toggles. We no longer restore the terminal in the `ReplToggleEvent::Disable` branch.
- We still restore the terminal on app exit.

Relevant code:
- `src/repl.rs::manage_context`: removed raw mode restore and resource removal on `Disable`.
- `src/repl.rs::cleanup_on_exit`: still restores raw mode.

## Rationale

- Ensures crossterm `KeyEvent`s (including the toggle key) are delivered immediately in both enabled and disabled states.
- Simplifies input flow: REPL run state is controlled by `run_if(repl_is_enabled)` gating, not by toggling the terminal mode.

## Alternatives Considered

- Use Bevy's `ButtonInput<KeyCode>` for toggling when REPL is disabled and crossterm when enabled.
  - Pros: Avoids always-on raw mode.
  - Cons: Two input paths to maintain; less consistent behavior.

## Impact

- Users can toggle the REPL at any time without needing to press Enter.
- This is consistent across examples and custom apps.

## Notes

- If your application needs to temporarily disable raw mode for other reasons, ensure the REPL toggle remains accessible (e.g., by switching to Bevy input during those periods).
 
---

# Design Decision: Prompt visual modes (minimal vs pretty)

Date: 2025-08-09

## Summary

- Provide two visual modes for the REPL prompt bar:
  - Minimal: 1-line bar, no border/colors/hints.
  - Pretty: 1-line bar with border, title, colorful styles, and right-aligned hint.
- “Pretty” is gated behind a Cargo feature `prompt-pretty`.

## Implementation

- Added single configuration resource `ReplPromptConfig` in `src/prompt/mod.rs` with fields:
  - `border: bool` (default true)
  - `color: bool` (default false)
  - `hint: bool` (default true)
- Implemented renderer in `src/prompt/render.rs::display_prompt()` using ratatui via `ReplContext`:
  - Fixed bottom bar (1 row content) with horizontal scrolling to keep cursor visible.
  - Optional border/title, styled prompt symbol, and right-aligned hint.
- New submodule `src/prompt/visual/`:
  - `PromptMinimalPlugin` (no feature): sets `border=false, color=false, hint=false`.
  - `PromptPrettyPlugin` (feature-gated): sets `border=true, color=true, hint=true`.
- Cargo feature: `prompt-pretty` in `Cargo.toml`.
- `src/plugin.rs::ReplPlugins` conditionally adds `PromptPrettyPlugin` when the feature is enabled.

## Rationale

- Keeps runtime configuration simple and overridable via one resource.
- Feature-gating the pretty mode avoids pulling in optional styling paths for minimal users.
- Renderer constrained to 1-line output to avoid covering normal stdout and to keep the prompt fixed at the bottom.

## Future Work

- Optional multi-line wrapping mode behind a separate knob.
- Theming (color choices), and togglable cursor style via crossterm if desired.

# 2025-08-09 Review

## README Design Assessment (`README.md`)

- __Scope__: Terminal REPL for headless Bevy using `clap` parsing and `bevy_ratatui` I/O. Provides toggleable input area and observer-based command execution. Public API exposed via `bevy_repl::prelude::*`.
- __Strengths__:
  - Clear positioning as alternative to `bevy-console` for terminal-first apps.
  - Two authoring styles for commands: builder and optional derive.
  - Schedules and integration with `bevy_ratatui::event::InputSet` documented.
- **Gaps / Inconsistencies**:
  - Feature flag naming mismatch: table shows `default_commands`, usage shows `features = ["default-commands"]`. Pick one and standardize (prefer underscore in Cargo feature names or align with existing in `Cargo.toml`).
  - Method name inconsistency in examples: trait uses `fn clap_command()` but later example uses `fn command()`; should be `clap_command()` everywhere.
  - Known issues list includes non-functional `help`/`clear`; either disable by default or fix soon.
  - Raw mode/toggle narrative conflicts with current code (see below).

## Example Ergonomics (`examples/`)

Files present: `minimal.rs`, `toggle.rs`, `builder.rs`, `derive.rs`, `builtins.rs`, `key_events.rs`, `update_resource.rs`, `aliases.rs`, `window.rs`.

- __API Surface__: Via `prelude` in `src/lib.rs`, users get `ReplPlugin`, `ReplDefaultCommandsPlugin`, `ReplPlugins` group, `ReplAppExt::add_repl_command::<T>()`, events (`ReplSubmitEvent`, etc.). Looks ergonomic: add plugin(s), register commands, add observer systems.
- __Derive path__: Feature-gated via `bevy_repl_derive::ReplCommand`. README snippet aligns with this, but confirm feature flag spelling in `Cargo.toml` and docs.
- __Headless usage__: README shows `MinimalPlugins` + `ScheduleRunnerPlugin`. Good; examples should mirror that consistently.
- __Toggling__: README states backquote toggles; note reliability issue listed under Known Issues.

## Code Quality Snapshot

- __Structure__: Core in `src/repl.rs` (plugin, state, events, terminal context). Parsing/registration in `src/command/` with `ParserPlugin`, `CommandParser`, `ReplAppExt`. Prompt split into `input.rs`, `keymap.rs`, `render.rs`.
- __Docs__: `lib.rs` inlines `README.md` as crate docs. Public items re-exported via `prelude`.
- __Scheduling__: `ReplSet::{Toggle,Capture,Buffer,Render,Post}` chained between `InputSet::EmitCrossterm` and `InputSet::Post` — coherent.
- **Observations / Risks**:
  - Raw mode lifecycle: Current code restores raw mode on `Disable` in `manage_context()` and on exit in `cleanup_on_exit()`. This contradicts the note at top (always-on raw mode). Decide one behavior and align code + README. Always-on raw mode likely fixes toggle reliability.
  - Feature flag naming mismatch as above.
  - Example/API consistency: ensure all examples use `clap_command()` and compile under MSRV/bevy version.
  - Tests: No unit/integration tests found for parsing or buffer editing. Add at least parser and buffer tests.
  - Built-ins: `help`/`clear` listed as non-functional; consider hiding behind feature off by default or mark experimental.

### Design Decision (2025-08-09)

- __No runtime toggle in v1__: For the first iteration, the REPL will not be toggleable while the app is running. If `ReplPlugin` is added but the REPL is disabled at startup, the app must behave as if the REPL were not present.
  - Implications:
    - No keybind for toggling; remove toggle systems and events from v1 path.
    - When disabled, do not acquire terminal/enable raw mode, do not register REPL systems, and avoid side effects (events/resources) that alter scheduling.
    - Documentation and examples should reflect a static enabled/disabled configuration.

## Today’s Plan (prioritized)

1. __Make REPL inert when disabled__
   - Update `ReplPlugin` build to short-circuit: if disabled at startup, do not insert REPL resources, events, or systems; avoid raw mode/terminal acquisition.
   - Remove runtime toggle systems/events from v1 path; keep minimal code behind a feature flag or comment for future work.
2. **Update README and examples for v1**
   - State explicitly: no runtime toggle in v1; REPL is enabled/disabled at startup only.
   - Standardize feature flag spelling and `clap_command()` naming in snippets.
   - Ensure `examples/minimal.rs` shows static enabled REPL; add a `disabled` example showing no side effects.
3. **Built-ins sanity**
   - Make `help` and `clear` functional or exclude from default plugin and mark as experimental.
4. **Add basic tests**
   - Verify that when disabled, no REPL systems run and no terminal/raw mode is entered.
   - Parser: round-trip a sample command string to event struct.
   - Buffer: cursor movement, insert/delete/backspace.
5. (Stretch) **Post-v1 toggle plan (tracked only)**
   - Document future toggle approach and raw mode strategy; do not implement in v1.

## Quick Links

- `src/repl.rs`: plugin/state/events/raw mode
- `src/command/mod.rs`: `ReplCommand`, `ReplAppExt`, parsers
- `src/prompt/`: input, keymap, render
- `src/plugin.rs`: `ReplPlugins` group

---


# Design Note: Alternate-Screen Pane via bevy_ratatui (2025-08-09)

## Summary

- Current approach draws on the main terminal screen using `ReplContext` and a `PromptRenderer` strategy. Regular stdout can overwrite/scroll the prompt, so pretty styling may not appear consistently.
- Proposed approach uses bevy_ratatui’s default terminal context in the alternate screen. We render a scrollable log pane (top) and the prompt bar (bottom) deterministically within ratatui. Keep the `PromptRenderer` trait and `ActiveRenderer` for styles.

## Complexity Comparison

- **Lifecycle**
  - Current: custom `ReplContext` manages raw mode/screen; enable/disable observers.
  - Proposed: rely on `RatatuiPlugins` for raw mode, alt screen, errors, cleanup.
- **Rendering**
  - Current: prompt drawn once; stdout can overwrite it; early-returns on tight height/width.
  - Proposed: full-frame layout each tick; prompt always visible; no stdout overwrite.
- **Key input**
  - Current/Proposed: unchanged; still via `bevy_ratatui::event::EventPlugin` and `ReplSet` ordering.
- **Logging**
  - Current: stdout to terminal (uncontrolled).
  - Proposed: optional `LogBuffer` + `tracing` layer to render logs in pane; can forward to stdout when REPL disabled.

Net: Proposed path reduces bespoke terminal management and makes rendering predictable.

## Does It Meet Objectives?

- **Extensibility**: Preserve `PromptRenderer` strategy; `ActiveRenderer` allows custom styles.
- **Reliability/UX**: Pretty styling consistently visible; no overwrite/scroll races.
- **Minimal surface area**: Limit changes to `src/prompt/`, README, and examples. Command flow unchanged.
- **Defaults-first**: Use ratatui defaults; less custom lifecycle code.

## Problems Addressed

- **Prompt overwritten by stdout**: Eliminated by rendering in alternate screen.
- **Height/width early returns hide prompt**: Mitigated by controlled full-frame layout.
- **Ordering/race conditions**: Ratatui frame is authoritative; stdout doesn’t repaint over it.
- **Terminal cleanup hazards**: Centralized in bevy_ratatui.

## Risks / Tradeoffs

- Not the raw terminal view; pane lives in alternate screen (intentional for reliability).
- Log capture needed to populate the pane (small `tracing` layer). Memory bound via ring buffer.
- Feature management if we gate the pane (keep both paths clean).

## Minimal Migration Sketch

- Cargo.toml: require Bevy `bevy_tracing` with `bevy_log`.
- `src/prompt/render.rs`: `display_prompt()` tries `ResMut<bevy_ratatui::context::TerminalContext>` first; falls back to `ReplContext` for compatibility.
- Optional: if `LogBuffer` resource exists, render it above the prompt; otherwise render prompt only (no behavior change).
- Examples: add `RatatuiPlugins` to pretty/custom demos; small `tracing_subscriber` layer to push logs to `LogBuffer`.
- README: document “pane mode” (alt screen), how to enable with `RatatuiPlugins`, and optional scrollback.

## Success Criteria

- Pretty styling reliably visible; prompt bar stable.
- Command parsing/observer flow unchanged.
- Fewer custom terminal lifecycle pieces; prompt module localized changes.
- Examples demonstrate pane + prompt and custom renderers.



---

# Implementation Note: Dual-Context Rendering + Plugin Split (2025-08-09)

## Summary

- Implemented a dual-context draw path in `src/prompt/render.rs::display_prompt()`:
  - Prefer `bevy_ratatui::RatatuiContext` (alternate screen) when present.
  - Fallback to existing `ReplContext` (main screen) for compatibility.
- Split plugin groups to give users integration choice:
  - `MinimalReplPlugins`: core REPL + prompt + parser, plus minimal input plumbing
    (bevy_ratatui `event::EventPlugin` for `KeyEvent`, `cleanup::CleanupPlugin`, and Bevy `InputPlugin`).
    No alternate screen, no built-in commands.
  - `ReplPlugins` (default/turnkey): composes `MinimalReplPlugins` +
    `bevy_ratatui::RatatuiPlugins` (alternate screen + defaults) + default commands.
- Added example `examples/minimal_no_ratatui.rs` demonstrating the fallback path with no
  alternate screen and custom commands only.

## Rationale

- Reduce bespoke terminal lifecycle code by leaning on `bevy_ratatui` where available, but keep
  backward compatibility and smaller integration surface for advanced users.
- Composition mirrors the Bevy ecosystem pattern (e.g., users can opt into full stacks or wire
  minimal sets). Avoids double-registration issues by centralizing default ratatui usage inside
  `ReplPlugins`, while `MinimalReplPlugins` remains lean and main-screen friendly.
- Keeps command flow, schedules, and renderer strategy intact; only the drawing backend is chosen
  at runtime depending on available context resources.

## Current State

- `ReplPlugins` renders in alternate screen; prompt is stable and not overwritten by stdout.
- `MinimalReplPlugins` renders on main screen; prompt works with the same buffer/parse flow.
- Examples verified:
  - `pretty` (feature `pretty`): alternate screen.
  - `update_resource`: alternate screen.
  - `minimal_no_ratatui`: main screen; custom `ping`/`exit` commands; no built-ins.

## Next Steps

- README updates:
  - Document how to choose between `MinimalReplPlugins` and `ReplPlugins` with short snippets.
  - Note the dual-context behavior and when the alternate screen is active.
- Optional log pane prototype:
  - Introduce a `LogBuffer` resource and a tiny `tracing` layer to capture logs.
  - Update `display_prompt()` (or a renderer strategy) to lay out a scrollable log pane above the prompt
    when `LogBuffer` is present; otherwise render prompt-only.
- Polishing:
  - Address or silence benign `dead_code` warning for `MinimalRenderer`.
  - Ensure examples consistently avoid double-adding `RatatuiPlugins`.

## Risks / Considerations

- `MinimalReplPlugins` adds Bevy `InputPlugin` to satisfy the REPL input-blocking system; this is
  acceptable overhead for minimal integration and keeps behavior consistent.
- Users integrating their own input pipeline may prefer to disable/replace the blocking system;
  this could be feature-gated in the future if needed.

---

# Design Note: Global ScrollRegionReadySet (2025-08-10)

## Summary

- Expose a public `ScrollRegionReadySet` system set unconditionally (in all builds), even when the pretty renderer is not enabled.
- Purpose: allow examples and downstream apps to consistently order their PostStartup output (e.g., instructions) after the scroll-region has been established in pretty mode, without needing feature gates.

## Problem

- In pretty mode, the prompt reserves the bottom lines using a terminal scroll region. Any startup prints must occur only after the region is established, or output can overlap/stack at the prompt.
- Previously, the `ScrollRegionReadySet` label existed only behind the `pretty` feature. This forced examples to use `cfg` guards or risk incorrect ordering when building with/without the feature.

## Change

- Define the label globally and configure it in the schedule so it always exists as a valid target for `.after(ScrollRegionReadySet)`.
- Only the pretty renderer populates this set with its `manage_pretty_scroll_region` system; in minimal mode, the set is present but empty (a no-op).

## Implementation

- `src/prompt/renderer/mod.rs`
  - Added `#[derive(SystemSet, ...)] pub struct ScrollRegionReadySet;`
  - In `PromptRenderPlugin::build()`, call `app.configure_sets(PostStartup, ScrollRegionReadySet);` unconditionally.
- `src/prompt/renderer/pretty.rs`
  - Removed local definition of the set; now `use super::ScrollRegionReadySet;`
  - Schedules `manage_pretty_scroll_region` into `.in_set(ScrollRegionReadySet)` during `PostStartup`.
- `src/lib.rs`
  - Re-export `ScrollRegionReadySet` from the prelude unconditionally.
- Examples (`examples/*.rs`)
  - Updated to call `.add_systems(PostStartup, instructions.after(ScrollRegionReadySet))` without `cfg` gates.

## Rationale

- Simplifies example and user code by removing feature-gated scheduling expressions.
- Keeps minimal builds unaffected: no scroll-region management runs in minimal mode; the label’s presence does not introduce side effects.
- Improves startup robustness in pretty mode across all examples and custom apps.

## Impact

- Pretty mode: deterministic startup printing with the prompt fixed at the bottom and output scrolling above it.
- Minimal mode: identical behavior as before. The ready set is merely an empty label, ensuring compatibility.

## Notes

- The scroll-region management remains encapsulated within the pretty renderer. Minimal users pay no runtime cost.
- If future modes require similar startup ordering, they can reuse the same global set or define additional sets as needed.
