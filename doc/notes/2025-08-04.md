# Learning Clap
2025-08-04

**Derive pattern**: define structs with fields as input parameters and add attribues
to the struct to specify the clap attributes.

```rust
#[derive(Parser)]
struct Args {
    #[arg(short, long)]
    verbose: bool,
}
```

**Builder pattern**: build the clap command step by step as a method chain.

```rust
let mut cmd = Command::new("my_app");
cmd.version("1.0.0");
cmd.author("John Doe");
cmd.about("Does awesome things");
```

For this application, we should support the builder pattern first, and later try
to support the derive pattern. We should aspire to build the system in a way
that allows the user to use any feature flag to build custom commands, and then
use the minimal set of features to build the base-level REPL.

Remember that the `bevy_crossterm` TUI configures the UI and captures text
input, but `clap` is still responsible for parsing it. Confusingly, this means
that we output a `Command` struct and do _not_ implement the `Parser` trait.
`Parser` is used in the derive pattern, but we will be creating `Command`s and
directly calling `get_matches()` on them.

I'm not sure how "low-level" the custom commands should be. For now, I think we
will have the user supply `Command` objects to the REPL, and then during runtime
we will call `get_matches()` on the inputs with all of the `Command`s.

## bevy_crossterm is out of date
Turns out `bevy_crossterm` hasn't been updated in 5 years, and the most recently
updated fork was from a year ago.

Looks like we should migrate to `bevy_ratatui` which has support for Bevy 0.16.

Notes on bevy_ratatui
- Natively handles Ctrl+C without additional setup
- We should allow the REPL to be enabled and disabled. When enabled, consume
  keystrokes as REPL input. When disabled, forward keystrokes to Bevy for game
  controls (as normal) with bevy_ratatui.
- All of the schedule stages are handled, so we should piggyback off of their
  work and simply inject our own stuff.
