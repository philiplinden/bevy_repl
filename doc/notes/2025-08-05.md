# 2025-08-05 - REPL Frame Sequence Analysis

## Low-Level Frame Sequence

This document explains the exact sequence of events that happens every frame in the REPL system, tracing through the specific code paths.

### Frame Start: Bevy's Update Schedule

```rust
// In your app setup:
app.add_systems(Update, observer);  // Your observer system
```

**Bevy's internal sequence:**
1. **Schedule Execution**: Bevy runs the `Update` schedule
2. **System Parallelization**: Systems run in parallel unless they have conflicting access
3. **Resource Access**: Systems request resources via dependency injection

### Your REPL Systems (All in Update Schedule)

#### 1. Terminal Input System (if you have one)
```rust
// This would be in your terminal.rs or similar
fn terminal_input_system(
    mut terminal: ResMut<BevyRatatuiTerminal>,
    // ... other inputs
) {
    // Captures keyboard input via bevy_ratatui
    // Updates terminal.current_line
}
```

#### 2. Parse Command System (from commands.rs:40-77)
```rust
pub fn parse_command_input<C: ReplCommand>(
    mut terminal: ResMut<crate::terminal::BevyRatatuiTerminal>,
    mut command_events: EventWriter<CommandTriggered<C>>,
) {
    let input = terminal.get_current_line().trim();  // Read from resource
    
    if input.is_empty() { return; }
    
    let args: Vec<&str> = input.split_whitespace().collect();
    
    match C::parse_from_args(&args) {  // Your clap parsing
        Ok(command) => {
            command_events.write(CommandTriggered {  // Emit event
                command,
                raw_input: input.to_string(),
            });
            terminal.clear_line();  // Clear input
        }
        Err(e) => {
            terminal.add_log_line(format!("Error: {}", e));  // Log error
            terminal.clear_line();
        }
    }
}
```

#### 3. Observer System (auto-generated in commands.rs:35-50)
```rust
// This is created by your ReplExt implementation:
let system = move |mut events: EventReader<CommandTriggered<C>>| {
    for event in events.read() {  // Read events from this frame
        let trigger = ReplTrigger {
            command: event.command.clone(),
            raw_input: event.raw_input.clone(),
        };
        observer(trigger);  // Call your function
    }
};
```

#### 4. Your Command Function (from examples/minimal.rs:44-52)
```rust
fn on_say(trigger: ReplTrigger<SayCommand>) {
    let command = &trigger.command;  // Access parsed command
    println!("Saying: {}", command.message);  // Output
    
    for i in 0..command.repeat {
        println!("  {}: {}", i + 1, command.message);
    }
}
```

### Bevy's Event Processing

**Event Lifecycle within the frame:**
1. **Event Emission**: `command_events.write()` queues event
2. **Event Reading**: `EventReader<CommandTriggered<C>>` reads events from this frame
3. **Event Clearing**: Events are cleared at end of frame

### System Dependencies & Ordering

```rust
// These systems run in Update schedule:
1. terminal_input_system (if exists)
   ↓ (depends on terminal resource)
2. parse_command_input<C> 
   ↓ (depends on terminal resource, writes events)
3. observer_system (auto-generated)
   ↓ (reads events, calls your function)
4. terminal_render_system (if exists)
   ↓ (reads terminal resource for display)
```

### Key Bevy Concepts in Play

- **Resources**: `BevyRatatuiTerminal` - shared state between systems
- **Events**: `CommandTriggered<C>` - one-shot communication between systems  
- **Systems**: Functions that run each frame with dependency injection
- **Schedules**: `Update` - when systems run (every frame)
- **Parallelization**: Systems run in parallel unless they access same data mutably

### Frame End

All systems complete, events are cleared, terminal renders output, frame ends.

**The entire sequence happens synchronously within one frame execution of Bevy's Update schedule.**

## Important Notes

- All REPL processing happens within a single frame, not across multiple frames
- Events are processed immediately, not queued for the next frame
- The system is responsive and synchronous
- Bevy's ECS architecture handles the parallelization and dependency management automatically 

## ReplTrigger vs CommandTriggered Analysis

### :construction: **Decision: Refactor to use Bevy's observer system**

**Key evidence:**
- [Bevy's `Trigger<E>`](https://docs.rs/bevy/latest/bevy/prelude/struct.Trigger.html) is designed for event observers in ECS
- Our custom `ReplTrigger<C>` and `CommandTriggered<C>` duplicate Bevy functionality
- Observer system provides better ECS integration and is more "Bevy-native"

**Current architecture issues:**
- Built-in commands incorrectly use `Trigger<C>` (Bevy's type) instead of `ReplTrigger<C>` (our type)
- Two separate event systems: Bevy's native vs our custom
- Type confusion and compilation errors

## **Refactoring plan:**

### **Replace custom system with Bevy observers**
```rust
// OLD: Custom event system
pub struct ReplTrigger<C: ReplCommand> { ... }
pub struct CommandTriggered<C: ReplCommand> { ... }
app.repl::<C>(observer_fn)

// NEW: Bevy observer system  
app.add_observer(|trigger: Trigger<C>| { ... })
```

### **Benefits of Bevy observer approach:**
- **ECS-native**: Better integration with Bevy's event system
- **Simpler**: Eliminates custom event/trigger types
- **Consistent**: Follows Bevy patterns and conventions
- **Powerful**: Access to Bevy's full observer capabilities

### **Implementation steps:**
1. **Update commands.rs**: Remove custom types, use Bevy observers
2. **Fix built-in commands**: Change to `Trigger<C>` with proper imports
3. **Update API**: Replace `.repl()` with `.add_observer()`
4. **Modify parsing**: Use `Commands::trigger()` instead of event emission

### **Architecture flow (new):**
1. Terminal input → `parse_command_input` system
2. System uses `commands.trigger(C)` to trigger observers
3. Bevy's observer system calls registered functions with `Trigger<C>`
4. Command handlers receive parsed command data via `trigger.event()`

**Status**: :white_check_mark: **Refactoring completed** - Successfully moved from custom event system to Bevy's native observer system. All files updated to use `Trigger<C>` instead of custom types. 