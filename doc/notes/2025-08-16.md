# ‚úÖ Unicode-safe prompt rendering fixes (2025-08-16)

## Conclusions / actions
- Implemented Unicode-correct windowing and cursor math for the minimal renderer.
- Prompt width and cursor x now use display columns, not bytes/chars.
- Removed an unused import.

## Key evidence
- `src/prompt/renderer/helpers.rs` now uses `unicode-segmentation` and `unicode-width` to:
  - Compute a grapheme-aware visible window: `buffer_window()` returns a slice that ensures the cursor grapheme is visible within `visible_width` display columns.
  - Compute cursor column within the visible slice: `cursor_position()` sums grapheme display widths between `start..cursor`.
- `src/prompt/renderer/minimal.rs`:
  - Uses `UnicodeWidthStr::width()` for `prompt_symbol` width.
  - Calls updated `cursor_position(left_area, prompt_width, buffer, start, cursor)`.
  - Dropped unused `bevy::prelude::*` import.
- Added dependencies in `Cargo.toml`:
  - `unicode-segmentation = "1.11"`
  - `unicode-width = "0.1.13"`

## Details
- Previous implementation mixed byte and character counts and assumed 1 column per char:
  - `prompt_symbol.len()` used bytes, misplacing the cursor for wide graphemes (CJK, emoji) and ignoring combining marks.
  - `buffer_window()` used `chars().skip(start)` where `start` was derived from the cursor byte index, risking misalignment for UTF-8.
  - `cursor_position()` computed `cursor - start` as columns, ignoring grapheme width.
- New approach:
  - `buffer_window(buffer, cursor, visible_width)`
    - Enumerates graphemes with byte offsets.
    - If total display width ‚â§ `visible_width`, returns the whole buffer.
    - Otherwise, finds the grapheme containing (or preceding) the cursor, then expands leftward until filling `visible_width` columns to ensure cursor visibility. Returns slice `[start_byte..cursor_grapheme_end]` and `start_byte`.
  - `cursor_position(left, prompt_width, buffer, start, cursor)`
    - Sums display widths of graphemes in `buffer[start..cursor]` to get the cursor's in-slice columns and clamps within `left`.
  - `minimal.rs` computes `prompt_width` via `UnicodeWidthStr::width()` and passes the full `buffer` to `cursor_position()`.

## Follow-ups (recommended)
- Add tests for grapheme/width cases:
  - ASCII, combining marks (e.g., "AÃÅ"), CJK (e.g., "‰Ω†Â•Ω"), emoji and ZWJ sequences (e.g., "üë®‚Äçüë©‚Äçüëß‚Äçüë¶").
- Consider right/left bias configuration for the window (e.g., keep a margin left of the cursor).
- Optionally add truncation indicators for long log lines in minimal mode.
- Review pretty renderer for similar width corrections if applicable.

## Files touched
- `src/prompt/renderer/helpers.rs`
- `src/prompt/renderer/minimal.rs`
- `Cargo.toml`

## Addendum: API consistency update (later on 2025-08-16)
- Refactored Unicode handling to use ratatui APIs for consistency:
  - Grapheme iteration via `Span::styled_graphemes(Style::default())`.
  - Display width via `Span::raw(text).width()`.
- Removed dependencies from `Cargo.toml`:
  - `unicode-segmentation`
  - `unicode-width`
- Behavior remains Unicode-correct for width and cursor/windowing, while depending only on ratatui‚Äôs public API surface.

## Addendum: Minimal vs Pretty logging behavior (later on 2025-08-16)

### Conclusions / actions
- Minimal renderer prints logs to stdout; it no longer draws logs in-frame.
- Pretty/alternate-screen renderer uses an in-frame `LogBuffer` with a ratatui scroll region.
- Wiring is mode-specific in `PromptPlugin::build()`.

### Key evidence
- `src/prompt/renderer/minimal.rs`: removed in-frame log rendering; only the prompt is drawn.
- `src/prompt/renderer/mod.rs`: stopped unconditionally adding `LogBufferPlugin`; pretty `ScrollRegionPlugin` remains feature-gated.
- `src/prompt/mod.rs`:
  - `PromptMode::InFrame` (Minimal): add `CaptureSubscriberPlugin` and `print_log_events_system` to print via `repl_println!`.
  - `PromptMode::AlternateScreen` (Pretty): add `LogBufferPlugin` for in-frame snapshots.

### Docs updated
- `README.md`: clarified Minimal (stdout) vs Pretty (in-frame) logging; updated examples and notes.

### Rationale
- Minimal mode should preserve terminal-native scrollback and avoid TUI duplication.
- Pretty mode benefits from integrated TUI log history aligned with the reserved prompt region.
